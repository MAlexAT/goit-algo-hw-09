# **Висновки щодо ефективності алгоритмів видачі решти**
Огляд завдання
У цьому завданні ми реалізували дві функції для видачі решти певною сумою монет заданих номіналів:

Жадібний алгоритм (find_coins_greedy) — алгоритм, який починає з найбільшого номіналу і поетапно зменшує суму, використовуючи монети максимально можливих значень.

Алгоритм динамічного програмування (find_min_coins) — алгоритм, який шукає найменшу кількість монет, необхідних для досягнення заданої суми, гарантуючи оптимальне рішення.

Порівняння результатів
Було протестовано обидва алгоритми на прикладі суми 113 з номіналами монет [50, 25, 10, 5, 2, 1].

# Жадібний алгоритм
Результат: {50: 2, 10: 1, 2: 1, 1: 1}
Час виконання: дуже швидкий для даної суми, оскільки жадібний алгоритм має лінійну складність і виконує мінімум операцій.
Переваги: працює швидко і підходить для ситуацій, коли необхідна швидка відповідь.
Недоліки: не завжди гарантує мінімальну кількість монет для всіх можливих наборів номіналів. Наприклад, для інших наборів монет алгоритм може не забезпечити оптимальне рішення.

# Алгоритм динамічного програмування
Результат: {50: 2, 10: 1, 2: 1, 1: 1}
Час виконання: дещо повільніший, ніж жадібний алгоритм для невеликих сум, але значно ефективніший, коли потрібно знайти оптимальне рішення для складних наборів номіналів.
Переваги: гарантує мінімальну кількість монет для будь-якого набору номіналів, тому завжди знаходить оптимальне рішення.
Недоліки: складніший в реалізації та може бути повільнішим для простих випадків або невеликих сум, де жадібний алгоритм забезпечує достатньо ефективне рішення.

# **Висновки**
Обидва алгоритми мають свої сильні сторони:

- Жадібний алгоритм підходить для випадків, коли важлива швидкість і номінали монет дозволяють отримати оптимальне рішення. Він є дуже ефективним для великих сум, коли оптимальне рішення не є критичним.

- Алгоритм динамічного програмування забезпечує оптимальне рішення для будь-якого набору номіналів, навіть якщо жадібний алгоритм не може досягти мінімальної кількості монет. Він є більш гнучким і підходить для ситуацій, коли необхідна точність і мінімізація кількості монет.

# *Таким чином, для задач, де номінали монет "дружні" до жадібного підходу, можна використовувати жадібний алгоритм як швидке рішення. Проте для гарантії мінімальної кількості монет або складніших наборів номіналів варто застосовувати алгоритм динамічного програмування.*